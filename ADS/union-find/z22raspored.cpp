/*                                       Распоред са максималним збиром профита
vreme	memorija	ulaz	izlaz	test primeri
0,15 s	64 Mb	standardni izlaz	standardni ulaz	

Дати су послови који сви трају јединично време и за сваки посао је познато 
који је крајњи рок да се заврши и колики је профит ако се тај посао заврши у року. 
Напиши програм који одређује максимални профит који се може остварити.

Улаз
Са стандардног улаза се учитава број послова n (1≤n≤50000), 
а затим за сваки посао рок завршетка (природан број од 1 до n) и профит (цео број од 1 до 100).

Излаз
На стандардни излаз исписати максимални профит.

Пример

Улаз
6
3 40
3 80
4 30
4 100
1 70
1 60

Излаз
290

Боље решење се постиже ако се употреби идеја структуре података за ефикасно одређивање унија. 
можемо креирати скупове термина такве да се у сваком скупу налазе групе повезаних термина тј. 
тако да сви термини у истом скупу имају заједничког најкаснијег слободног претходника. 
Крећемо од тога да су сви скупови једночлани тј. да је за сваки жељени термин он сам термин у коме се посао може завршити 
(сваки термин бива постављен као представник свог скупа). 
Када се неки посао закаже, тада се скуп коме је он припадао спаја са скупом који се налази непосредно испред термина
 у коме је заказан. Да бисмо могли да региструјемо и термине у којима више није могуће заказивати часове уводимо и 
 посебан термин 0 (и третирамо га као и све остале).

Прикажимо на примеру како можемо распоредити следеће послове

a: 3 40
b: 3 80
c: 4 30
d: 4 100
e: 1 70
f: 1 60
Након сортирања по профитима добијамо следећи редослед.

d: 4 100
b: 3 80
e: 1 70
f: 1 60
a: 3 40
c: 4 30
Крећемо од следећег стања низа родитеља и распоређених послова.

0 1 2 3 4
0 1 2 3 4
- - - - -
Посао d се може распоредити у термин 4 чиме добијамо:

0 1 2 3 4
0 1 2 3 3
- - - - d
Посао b се може распоредити у термин 3 чиме добијамо:

0 1 2 3 4
0 1 2 2 3
- - - b d
Посао е се може распоредити у термин 1 чиме добијамо:

0 1 2 3 4
0 0 2 2 3
- e - b d
Посао f се не може распоредити (пошто је представник његовог термина 1 сада једнак 0), па га прескачемо. 
Посао a распоређујемо у термин 2 (што је тренутни представник његовог термина 3) чиме добијамо

0 1 2 3 4
0 0 0 2 3
- e f b d
Посао e не можемо распоредити (јер је представник његовог термина нула). Ако радимо компресију путање, долазимо у стање

0 1 2 3 4
0 0 0 0 3
- e f b d
На крају ни посао f не можемо распоредити (јер је представник његовог термина нула). Ако радимо компресију путање, долазимо у стање

0 1 2 3 4
0 0 0 0 0
- e f b d
Приметимо да смо поступак распоређивања могли прекинути када је број распоређених послова достигао број укупан број термина.

*/

#include <bits/stdc++.h>
using namespace std;

vector<int> roditelj;

void init(int n) {
    roditelj.resize(n);
    for (int i = 0; i < n; i++)
        roditelj[i] = i; }

int nadji(int a) {
    while (roditelj[a] != a) {
        roditelj[a] = roditelj[roditelj[a]];
        a = roditelj[a]; }
    return a; }

void spoji(int a, int b) {
    roditelj[a] = b; }

int main() {
    int n; cin >> n;
    vector<pair<int, int>> poslovi(n);
    for (int i = 0; i < n; i++)
        cin >> poslovi[i].first >> poslovi[i].second; // rok i profit

    sort(begin(poslovi), end(poslovi), // sort po profitima, od vecih ka manjim...
        [](const auto &p1, const auto &p2) {
        return p1.second > p2.second; });

    int profit = 0;
    int broj = 0; // br. rasporedjenih
    int najrok = max_element(begin(poslovi), end(poslovi))->first; // najveci rok

    init(najrok + 1); // od 0 do najveci rok

    for (const auto & posao : poslovi) { // za svaki posao...
        int vreme = nadji(posao.first);
        if (vreme > 0) { // ako vreme nije zauzeto
            profit += posao.second; // dodaj ga u profit
            spoji(vreme, nadji(vreme - 1)); // to vreme je zauzeto, spusti ga za 1 ostalima
            broj++; // br. rasporedjenih
            if (broj == najrok) // svi su rasporedjeni?
                break; } }

    cout << profit << endl;
    
    return 0; }