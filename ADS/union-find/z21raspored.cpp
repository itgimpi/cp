/* Распоред са максималним збиром профита
vreme	memorija	ulaz	izlaz	test primeri
0,15 s	64 Mb	standardni izlaz	standardni ulaz	

Дати су послови који сви трају јединично време и за сваки посао је познато који је крајњи рок да се заврши и колики је профит ако се тај посао заврши у року. Напиши програм који одређује максимални профит који се може остварити.

Улаз
Са стандардног улаза се учитава број послова 
n
 (
1
≤
n
≤
50000
), а затим за сваки посао рок завршетка (природан број од 1 до 
n
) и профит (цео број од 1 до 100).

Излаз
На стандардни излаз исписати максимални профит.

Пример
Улаз
6
3 40
3 80
4 30
4 100
1 70
1 60
Излаз
290

Задатак решавамо грамзивим алгоритмом. Послове распоређујемо у опадајућем редоследу профита. 
Посао са највећим профитом распоређујемо у најкаснији термин у ком је то могуће (пре истека његовог рока завршетка).

Докажимо коректност претходне грамзиве стратегије. 
Претпоставимо да се посао са највећим профитом не налази у оптималном распореду. 
Ако постоји посао у распореду који се завршава пре рока завршетка посла са највећим профитом 
тада уместо њега можемо ставити посао са највећим профитом и тако добити већи профит, 
што је контрадикција са претпоставком оптималности. Дакле, посао са највећим профитом мора бити део распореда 
(ако постоји било који празан термин у коме се он може распоредити). 
У оптималном распореду он може бити распоређен у последњем термину у ком је то могуће. 
Наиме, ако је он распоређен пре тога, а тај термин је празан, просто га можемо извршити касније. 
Ако се у том термину налази неки други посао, онда та два посла можемо просто разменити, без промене укупног профита.

Имплементација овог поступка тече тако што послове сортирамо опадајуће по профиту, 
а затим за сваки посао са листе тражимо најкаснији термин у коме је могуће распоредити га. 
Ако такав термин не постоји, посао прескачемо, а у супротном га распоређујемо баш у том термину. 
Критично место је претрага термина за текући посао.

Оно што прво пада на памет је одржавање низа логичких вредности којима бележимо који је термин слободан, а који није. 
Слободан термин одређујемо линеарном претрагом тако што крећемо од термина непосредно пре рока завршетка и померамо се ка раније, 
све док су термин заузети. Та претрага може бити линеарне сложености (ако су сви термин заузети), 
што може довести до алгоритма чија је сложеност O(m⋅n) где је m број термина (најкаснији рок завршетка посла) док је n укупан број послова.
*/

#include <bits/stdc++.h>
using namespace std;

int main() {
    int n; cin >> n;
    vector<pair<int, int>> poslovi(n);
    for (int i = 0; i < n; i++)
        cin >> poslovi[i].first >> poslovi[i].second;

    sort(begin(poslovi), end(poslovi),
        [](const auto& p1, const auto& p2) {
            return p1.second > p2.second;        });

    int profit = 0;
    int brojRasporedjenih = 0;
    int maksRok = max_element(begin(poslovi), end(poslovi))->first;
    vector<bool> zauzeto(maksRok, false);
    for (const auto& posao : poslovi) {
        int vreme = posao.first - 1;
        while (vreme >= 0 && zauzeto[vreme])
            vreme--;
        if (vreme >= 0) {
            zauzeto[vreme] = true;
            profit += posao.second;
            brojRasporedjenih++;
            if (brojRasporedjenih == maksRok)
                break;        }    }

    cout << profit << endl;
    
    return 0; }