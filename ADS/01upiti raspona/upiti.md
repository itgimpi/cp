Низ збирова префикса, омогућава ефикасно постављање упита над сегментима низа, али не и ефикасно ажурирање елемената низа, јер је потребно ажурирати све збирове префикса након ажурираног елемента, сложеност најгорег случаја је $O(n)$. Низ разлика суседних елемената допушта стална ажурирања низа, међутим, извршавање упита очитавања стања низа подразумева реконструкцију низа, што је сложености $O(n).$

Нека се упити ажурирања низа и очитавања његових статистика јављају испреплетано. За разлику од претходних, статичких упита над распонима (енгл. static range queries), ово су _динамички упити над распонима_ (dynamic range queries), тако да треба развити структуре података које омогућавају извршавање оба типа упита ефикасно. На пример, прoблем имплементације структуре података која обезбеђује ефикасно израчунавање збирова сегмената датог низа одређених интервалима позиција $[a, b]$, при чему се појединачни елементи низа могу мењати.

Једна структура података која омогућава прилично једноставно и ефикасно решавање овог проблема су _сегментна стабла_. Опет се током фазе препроцесирања израчунавају збирови одређених сегмената полазног низа, а онда се збир елемената произвољног сегмента полазног низа изражава у функцији тих унапред израчунатих збирова. Сегментна стабла нису специфична само за сабирање, већ се могу користити и за друге статистике сегмената које се израчунавају асоцијативним операцијама (за одређивање најмањег или највећег елемента, нзд-а свих елемената и сл.).

Претпоставимо да је дужина низа степен броја 2 (ако није, низ се може допунити до најближег степена броја 2, најчешће нулама). Чланови низа представљају листове стабла. Групишемо два по два суседна чвора и на сваком наредном нивоу стабла чувамо родитељске чворове који чувају збирове своја два детета. Ако је дат низ $(3, 4, 1, 2, 6, 5, 1, 4)$, сегментно стабло за збирове изгледа:
```
              26
      10              16
  7       3       11      5
3   4   1   2   6   5   1   4
0   1   2   3   4   5   6   7
```
Пошто је дрво потпуно, најједноставнија имплементација је да се чува у низу (слично као у случају хипа). Нека се елементи стабла смештају од позиције $1$, јер је тада аритметика са индескима лакша (могу бити индексирани и класично, од нуле).
```
0  1  2  3  4  5  6  7  8  9  10 11 12 13 14 15
-  26 10 16 7  3  11 5  3  4  1  2  6  5  1  4 
```
Корен је смештен на позицији 1. Елементи полазног низа су на позицијама $[n,2n-1]$. Елемент који се у полазном низу налази на позицији $p$, је у сегментном стаблу на позицији $p+n$. Лево дете чвора $k$ је на позицији $2k$, а десно на позицији $2k+1$. Дакле, на парним позицијама су лева деца својих родитеља, а на непарним десна. Родитељ чвора $k$ је на позицији $(\lfloor{\frac{k}{2}}\rfloor)$.

Како да се одреди збир елемената на позицијама из сегмента $[2, 6]$, тј. збир елемената $1, 2, 6, 5, 1$? У сегментном стаблу тај сегмент је на позицијама $[2+8, 6+8] = [10,14]$. Збир прва два елемента $1, 2$ је у чвору изнад њих, збир наредна два елемента $6, 5$ такође, док је у родитељском чвору елемента $1$ његов збир са елементом $4$, који не припада сегменту који се сабира. Зато збир елемената на позицијама $[10, 14]$ у сегментном стаблу може да се разложи на збир елемената на позицијама $[5, 6]$ и елемента на позицији $14$.

Како да се одреди збир елемената на позицијама из сегмента $[3, 7]$, тј. збир елемената $2, 6, 5, 1, 4$? У сегментном стаблу тај сегмент је на позицијама $[3+8, 7+8] = [11, 15]$. У родитељском чвору елемента $2$ је његов збир са елементом $1$ који не припада сегменту који се сабира. Збирови елемената $6$ и $5$ и елемената $1$ и $4$ су у чворовима иза њих, а збир сва четири дата елемента у чвору изнад њих.

Уместо операције којом се мења члан низа на позицији $i$ и додељује вредност $v$, често се разматра функција која елемент низа на позицији $i$ полазног низа увећава за дату вредност $v$ и ажурира сегментно стабло. Свака од ове две функције се лако изражава преко оне друге.

Имплементација сегментног стабла за друге асоцијативне операције је скоро идентична, осим што се оператор `+` мења другом операцијом.

https://petlja.org/biblioteka/r/Zbirka3/00%20napredne_strukture_podataka/03%20upiti_raspona/02%20segmentna_stabla

vreme	memorija	ulaz	izlaz	test primeri
0,95 s	64 Mb	standardni izlaz	standardni ulaz	
Суме сегмената променљивог низа

Напиши програм који израчунава збирове датих сегмената низа (поднизова узастопних елемената), при чему се током рада програма поједини елементи низа могу мењати.

Улаз
У првој линији стандардног улаза налази се број n (1≤n≤100000), а у наредној линији низ од n елемената (елементи су цели бројеви између 0 и 10, раздвојени са по једним размаком). У наредној линији налази се број m (1≤m≤100000), а у наредних m линија упити. Подржане су две врсте упита:

p i v – извршавање овог упита подразумева да се у низ на позицију i упише вредност v (0≤i<n, 0≤v≤10).

z a b – извршавање овог упита подразумева да се израчуна и на стандардни излаз испише збир елемената низа који су на позицијама [a,b].

Излаз
Стандардни излаз садржи резултате z упита (сваки у посебној линији).

Пример
Улаз
5
1 2 3 4 5
5
z 0 4
z 2 3
p 2 5
p 3 6
z 0 4
Излаз
15
7
19

Суме сегмената
променљивог низа - Решење

Решење грубом силом подразумева да се одржава низ, да се упити p извршавају директном променом елемената низа (то се ради у O(1)), а да се упити z извршавају сабирањем елемената низа (то се ради у времену O(n)). Укупна сложеност таквог приступа је O(mn).

```cpp
#include <iostream>
#include <vector>
#include <numeric>

using namespace std;

int main() {
    ios_base::sync_with_stdio(false); cin.tie(0);
    int n; cin >> n;
    vector<int> niz(n);
    for (int i = 0; i < n; i++)
        cin >> niz[i];
    int m; cin >> m;
    for (int i = 0; i < m; i++) {
        string upit;
        cin >> upit;
        if (upit == "p") {
          int i, v; cin >> i >> v >> ws;
          niz[i] = v;
        } else if (upit == "z") {
          int a, b; cin >> a >> b;
          cout << accumulate(next(begin(niz), a), next(begin(niz), b+1), 0) << '\n';
      }
    }
    return 0;
}
```

Задатак можемо ефикасније решити ако збирове одржавамо у сегментном дрвету. Операције над дрветом можемо реализовати навише (од листова према корену).

Формирање сегментног дрвета на основу датог низа је веома једноставно. Прво се елементи полазног низа прекопирају у дрво, кренувши од позиције n. Затим се сви унутрашњи чворови дрвета (од позиције n−1, па уназад до позиције 1) попуњавају као збирови своје деце (на позицију k уписујемо збир елемената на позицијама 2k и 2k+1). Сложеност ове операције је очигледно линеарна у односу на дужину низа n.

За све унутрашње елементе сегмента смо сигурни да се њихов збир налази у чворовима изнад њих. Једини изузетак могу да буду елементи на крајевима сегмента. Ако је елемент на левом крају сегмента лево дете (што је еквивалентно томе да се налази на парној позицији) тада се у његовом родитељском чвору налази његов збир са елементом десно од њега који такође припада сегменту који треба сабрати (осим евентуално у случају једночланог сегмента). У супротном (ако се налази на непарној позицији), у његовом родитељском чвору је његов збир са елементом лево од њега, који не припада сегменту који сабирамо. У тој ситуацији, тај елемент ћемо посебно додати на збир и искључити из сегмента који сабирамо помоћу родитељских чворова. Ако је елемент на десном крају сегмента лево дете (ако се налази на парној позицији), тада се у његовом родитељском чвору налази његов збир са елементом десно од њега, који не припада сегменту који сабирамо. И у тој ситуацији, тај елемент ћемо посебно додати на збир и искључити из сегмента који сабирамо помоћу родитељских чворова. На крају, ако се крајњи десни елемент налази у десном чвору (ако је на непарној позицији), тада се у његовом родитељском чвору налази његов збир са елементом лево од њега који припада сегменту који сабирамо (осим евентуално у случају једночланог сегмента). Пошто се у сваком кораку дужина сегмента [a,b] полови, а она је у почетку сигурно мања или једнака n, сложеност ове операције је O(logn).

Приликом ажурирања неког елемента потребно је ажурирати све чворове на путањи од тог листа до корена. С обзиром да знамо позицију родитеља сваког чвора и ова операција се може веома једноставно имплементирати. Пошто се k полови у сваком кораку петље, а крећа од вредности највише 2n−1, и сложеност ове операције је O(logn).

```cpp
#include <iostream>
#include <algorithm>
#include <vector>

using namespace std;

// najmanji stepen dvojke veci ili jednak od n
int stepenDvojke(int n) {
    int s = 1;
    while (s < n)
        s <<= 1;
    return s; }

// na osnovu niza a dužine n u kom su elementi od pozicije 0
// formira se drvo i elementi mu se smeštaju u niz od pozicije 1
vector<int> formirajDrvo(const vector<int>& a) {
    int n = stepenDvojke(a.size());
    vector<int> drvo(2*n, 0);
    // kopira originalni niz u listove
    copy(begin(a), end(a), next(begin(drvo), n));
    // ažurira roditelje već upisanih elemenata
    for (int k = n-1; k >= 1; k--)
        drvo[k] = drvo[2*k] + drvo[2*k+1];
    return drvo; }

// izračunava se zbir elemenata polaznog niza dužine n koji se 
// nalaze na pozicijama iz segmenta [a, b] na osnovu segmentnog drveta
// koje je smešteno u nizu drvo, od pozicije 1
int zbirSegmenta(const vector<int>& drvo, int a, int b) {
    int n = drvo.size() / 2;
    a += n; b += n; // ineksi u stablu
    int zbir = 0;
    while (a <= b) {
        if (a % 2 == 1) // levi nepar?
            zbir += drvo[a++];
        if (b % 2 == 0) // desni par?
            zbir += drvo[b--];
        a /= 2;
        b /= 2; }
    return zbir; }

// ažurira segmentno drvo smešteno u niz od pozicije 1
// koje sadrži elemente polaznog niza a dužine n u kom su elementi
// smešteni od pozicije 0, nakon što se na poziciju i polaznog
// niza upiše vrednost v
void postavi(vector<int>& drvo, int i, int v) {
    int n = drvo.size() / 2;
    // prvo ažurira odgovarajući list
    int k = i + n;
    drvo[k] = v;
    // onda i sve roditelje izmenjenih čvorova
    for (k /= 2; k >= 1; k /= 2)
        drvo[k] = drvo[2*k] + drvo[2*k+1];
}

int main() {
    ios_base::sync_with_stdio(false); cin.tie(0);
    int n; cin >> n;
    vector<int> a(n);
    for (int i = 0; i < n; i++) // orig. niz
        cin >> a[i];

    vector<int> drvo = formirajDrvo(a);
    int m; cin >> m; // br. upita

    for (int i = 0; i < m; i++) {
        string upit; cin >> upit;

        if (upit == "p") { // upis
            int i, v; cin >> i >> v >> ws;
            postavi(drvo, i, v); } 
            
        else if (upit == "z") { // zbir
            int a, b; cin >> a >> b; // od a do b
            cout << zbirSegmenta(drvo, a, b) << '\n'; } }
    return 0; }
```
