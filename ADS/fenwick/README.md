**Фенвиково стабло** тј. бинарно индексирано стабло (Binary Indexed Tree, **BIT**) користе мало мање меморије и могу бити за константни фактор бржа од сегментних (сложеност је асимптотски једнака). 
За разлику од сегментних која су погодна за различите операције, 
Фенвикова стабла су специјализована само за асоцијативне операције које имају инверз 
(нпр. збирови или производи елемената сегмената, али не и минимуми, нзд-ови и сл.). Сегментна стабла могу да ураде све што и Фенвикова, обрнуто не важи.

Фенвиково стабло није стабло, то је низ збирова неких сегмената, 
изабраних на основу бинарног представљања индекса низа.

Вредности у низу се смештају од позиције $1$ и у полазном низу и у низу у ком се смешта стабло. 
Ако се елементи смештају од позиције $0$, на почетку сваке функције која ради са стаблом индекс полазног низа треба да се увећа за један. Ако је полазни низ дужине $n$, елементи стабла ће се смештати у нови низ на позиције $[1,n]$.

Индекс $i$ у стаблу је **горња граница** сегмента збира који се памти у Фенвиковом низу.
**Доња граница** се добија када се из броја $i$ избаци **најдеснији бит 1** и сабере са 1:

```
gg i      без 1    +1 dg  123456   10   15   20   25   30
 1 000001 000000  0+1  1  X--------+---------+---------+-- а[1]
 2 000010 000000  0+1  1  XX-------+---------+---------+-- а[1]+а[2]
 3 000011 000010  2+1  3  --X------+---------+---------+-- а[3]
 4 000100 000000  0+1  1  XXXX-----+---------+---------+-- а[1]+а[2]+а[3]+а[4]
 5 000101 000100  4+1  5  ----X----+---------+---------+-- а[5]
 6 000110 000100  4+1  5  ----XX---+---------+---------+-- а[5]+а[6]
 7 000111 000110  6+1  7  ------X--+---------+---------+-- а[7]
 8 001000 000000  0+1  1  XXXXXXXX-+---------+---------+-- а[1]+а[2]+а[3]+а[4]+а[5]+а[6]+а[7]+а[8]
 9 001001 001000  8+1  9  --------X+---------+---------+-- а[9]
10 001010 001000  8+1  9  --------XX---------+---------+-- а[9]+а[10]
11 001011 001010 10+1 11  ---------+X--------+---------+-- а[11]
12 001100 001000  8+1  9  --------XXXX-------+---------+-- а[9]+а[10]+а[11]+а[12]
13 001101 001100 12+1 13  ---------+--X------+---------+-- а[13]
14 001110 001100 12+1 13  ---------+--XX-----+---------+-- а[13]+а[14]
15 001111 001110 14+1 15  ---------+----X----+---------+-- а[15]
16 010000 000000  0+1  1  XXXXXXXXXXXXXXXX---+---------+-- а[1]+а[2]+а[3]+а[4]+а[5]+а[6]+а[7]+а[8]+а[9]+а[10]+а[11]+а[12]+а[13]+а[14]+а[15]+а[16]
17 010001 010000 16+1 17  ---------+------X--+---------+-- а[17]
18 010010 010000 16+1 17  ---------+------XX-+---------+-- а[17]+а[18]
19 010011 010010 18+1 19  ---------+--------X+---------+-- а[19]
20 010100 010000 16+1 17  ---------+------XXXX---------+-- а[17]+а[18]+а[19]+а[20]
21 010101 010100 20+1 21  ---------+---------+X--------+-- а[21]
22 010110 010100 20+1 21  ---------+---------+XX-------+-- а[21]+а[22]
23 010111 010110 22+1 23  ---------+---------+--X------+-- а[23]
24 011000 010000 16+1 17  ---------+------XXXXXXXX-----+-- а[17]+а[18]+а[19]+а[20]+а[21]+а[22]+а[23]+а[24]
25 011001 011000 24+1 25  ---------+---------+----X----+-- а[25]
26 011010 011000 24+1 25  ---------+---------+----XX---+-- а[25]+а[26]
27 011011 011010 26+1 27  ---------+---------+------X--+-- а[27]
28 011100 011000 24+1 25  ---------+---------+----XXXX-+-- а[25]+а[26]+а[27]+а[28]
29 011101 011100 28+1 29  ---------+---------+--------X+-- а[29]
30 011110 011100 28+1 29  ---------+---------+--------XX-- а[29]+а[30]
31 011111 011110 30+1 31  ---------+---------+---------+X- а[31]
32 100000 000000  0+1  1  XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX а[1]+а[2]+а[3]+а[4]+а[5]+а[6]+а[7]+а[8]+а[9]+а[10]+а[11]+а[12]+а[13]+а[14]+а[15]+а[16]+а[17]+а[18]+а[19]+а[20]+а[21]+а[22]+а[23]+а[24]+а[25]+а[26]+а[27]+а[28]+а[29]+а[30]+а[31]+а[32]
```
Поред високог степена симетрије, може да се примети да 16 елемената стабла памти само један (и то непарне индексе) елемент низа, 8 елемената су збирови по 2 ( непарни и парни индекс) елемента низа, 4 елемента су збирови 4 елемента низа, 2 елемента су збирови 8 елемента низа и по један (прва половина) од 16 и један од (сви елементи) 32 елемента низа.   

Надовезивањем интервала $[1,16]$, $[17,20]$ и $[21,21]$ добија се интервал $[1,21]$ тј. збир елемената низа до позиције $21$. Збир елемената се, дакле, може добити као збир неколико елемената записаних у Фенвиковом стаблу. Ово важи за било који индекс,не само за $21$. Број елемената чијим се сабирањем добија збир префикса је само $O(logn)$. У сваком кораку се број јединица у бинарном запису текућег индекса смањује, а број $n$ се записује са највише $O(logn)$ бинарних јединица.



Из бинарног записа броја треба да се избаци прва десна јединица. Ако се користи потпуни комплемент, `k&(-k)` је број који садржи само једну јединицу и то на месту последње јединице у запису броја `k`. Одузимањем те вредности од броја `k` тј. изразом `k-k&(-k)` брише се последња јединица у бинарном запису броја `k`. Други начин је да се израчуна вредност `k&(k-1)`. 

```
Збир од првог до 21. елемента:

Први сегмент је на позицији 21. Сваки следећи се добија избацивањем крајње десног бита 1 (k -= k & -k):

k = 21 = 010101, 21нк је 101010, 21пк је 101011, к&-к = 010101&101011 = 000001=1, 21-1=20
k = 20 = 010100, 20нк је 101011, 20пк је 101100, к&-к = 010100&101100 = 000100=4, 20-4=16
k = 16 = 010000, 16нк је 101111, 17пк је 110000, к&-к = 010000&110000 = 010000=1, 16-16=0
21. сегмент садржи само 21. ел., 20. сегмент садржи 17,18,19,20, 16. садржи од 1 до 16. То су сви од 1. до 21. елемента.
```
```cpp
// na osnovu Fenvikovog stabla, smeštenog u niz stablo
// računa se zbir prefiksa (0, k] polaznog niza
int zbirPrefiksa(int stablo[], int k) {
    int zbir = 0;
    while (k > 0) {
        zbir += stablo[k];
        k -= k & -k;
    }
}
```
Предност Фенвиковог стабла је ефикасно ажурирање. Ажурирање стабла после увећања елемента у низу на позицији `k` за вредност `x`: за `x` треба увећати све збирове у стаблу у којима се као сабирак јавља и елемент на позицији `k`. Индекси се рачунају слично, само што се уместо одузимања вредности `k&(-k)` број `k` у сваком кораку повећава за `k&(-k)`.



```
Ажурирање 21. елемент низа:

Треба да се ажурирају сегменти: 21, 22, 24 и 32, свуда где се појављује елемент 21.

Ажурира се к=21. Следећи сегмент (супротно претходном примеру) је k += k & -k.

k = 21 = 010101, 21нк је 101010, 21пк је 101011, к&-к = 010101&101011 = 000001=1, 21+1=22
к = 22 = 010110, 22нк је 101001, 22пк је 101010, к&-к = 010110&101010 = 000010=2, 22+2=24
к = 24 = 011000, 24нк је 100111, 24пк је 101000, к&-к = 011000&101000 = 001000=8, 24+8=32
```

```cpp
// Ažurira Fenvikovo stablo smešteno u niz stablo nakon što se
// u originalnom nizu element na poziciji k uveća za x
void dodaj(int stablo[], int n, int k, int x) {
    while (k <= n) {
        stablo[k] += x;
        k += k & -k;
    }
}
```

Збир сегмента $[a,b]$ је разлика збира $[1,b]$ и збира $[1,a−1]$. Оба се рачунају у $O(logn)$, и збир сваког сегмента се рачуна у времену $O(logn)$.



пример 2

За низ $3,4,1,2,6,5,1,4$, Фенвиково стабло је:

```
0    1      2     3     4     5     6     7     8  k
     1     10    11   100   101   110   111  1000  k  binarno
     0      0    10     0   100   100   110     0  f(k) binarno
 (0,1]  (0,2] (2,3] (0,4] (4,5] (4,6] (6,7] (0,8]  interval
 [1,1]  [1,2] [3,3] [1,4] [5,5] [5,6] [7,7] [1,8]  interval
     3      4     1     2     6     5     1     4  niz
     3      7     1    10     6    11     1    26  stablo
```

```
n bin  f n  опсег  12345678 3 4 1 2 6 5 1 4  fen
1 0001 0000 [1,1]  X------- 3                 3
2 0010 0000 [1,2]  XX------ 3+4               7
3 0011 0010 [3,3]  --X-----     1             1
4 0100 0000 [1,4]  XXXX---- 3+4+1+2          10 
5 0101 0100 [5,5]  ----X---         6         6
6 0110 0100 [5,6]  ----XX--         6+5      11
7 0111 0110 [7,7]  ------X-             1     1
8 1000 0000 [1,8]  XXXXXXXX 3+4+1+2+6+5+1+4  26

8 je 1000, збир свих елемената 
4 je 0100, збир прва 4 елемента 
2 je 0010, збир прва 2 елемената 
6 je 0110, збир прва елемената 5 и 6
1 je 0001, елемент 1
3 je 0011, елемент 3
5 je 0101, елемент 5
7 je 0111, само ел. 7
```

Нпр. $к=5=101$, $НК=010$, $ПК=011$, $к\&-k = 101\&011=001$, $101-001=100$.

Или $к=6=110$, $НК=001$, $ПК=010$, $к\&-k = 110\&010=010$, $110-010=100$.

Други начин да се то уради је да се израчуна вредност `k&(k-1)`. Нпр. $k=5=101$, $k-1=4=100$, $k\&k-1 = 101\&100=100$.

Збир префикса $[0,k]$ полазног низа:

 
```
n bin  f n  опсег  12345678 3 4 1 2 6 5 1 4  fen
1 0001 0000 [1,1]  X------- 3                 3
2 0010 0000 [1,2]  XX------ 3+4               7
3 0011 0010 [3,3]  --X-----     1             1
4 0100 0000 [1,4]  XXXX---- 3+4+1+2          10 
5 0101 0100 [5,5]  ----X---         6         6
6 0110 0100 [5,6]  ----XX--         6+5      11
7 0111 0110 [7,7]  ------X-             1     1
8 1000 0000 [1,8]  XXXXXXXX 3+4+1+2+6+5+1+4  26

8 je 1000, збир свих елемената 
4 je 0100, збир прва 4 елемента 
2 je 0010, збир прва 2 елемената 
6 je 0110, збир елемената 5 и 6
1 je 0001, елемент 1
3 je 0011, елемент 3
5 je 0101, елемент 5
7 je 0111, само ел. 7

Збир сегмента [3,7] је разлика збирова сегмената [1,7] и [1,2], тј. збир од 3. до 7. елемента је (збир од 1. до 7. ел.) - (збир од 1. до 2. ел.)

Збир сегмента [1,7]? 7 је 0111(7. из стабла је 7. ел., 1) -> 0110(6. из стабла је збир 5. и 6. ел., 6+5) -> 0100(4. из стабла је збир прва 4 ел., 3+4+1+2) -> 0000. Дакле, 3+4+1+2(прва 4)+6+5(5. и 6.)+1(7.)

Збир сегмента [1,2]? 2 је 10(2. из стабла је збир прва 2 ел., 3+4) -> 00. Дакле, 3+4.
            1 2 3 4 5 6 7     1 2    3 4 5 6 7 (од 3. до 7.)
Одузимањем (3+4+1+2+6+5+1) - (3+4) = 1+6+5+1+2
```

Због ове операције важно је да асоцијативна операција која се користи у Фенвиковом стаблу има инверз (у овом случају да се одузимањем две вредности префикса добије збир произвољног сегмента).

На пример, ако би се у претходном примеру елемент на позицији 3 увећао за 4, треба повећати за 4 вредности елемената Фенвиковог стабла на позицијама 3, 4 и 8. До ових позиција се долази од бинарног записа броја 3 који је 011 сабирањем са 1 (број који садржи тачно једну јединицу на позицији последње јединице у бинарном запису датог броја) чиме би добили 100 што одговара броју 4, а након тога бисмо ову вредност сабрали са 100 чиме бисмо добили 1000 (бинарни запис броја 8). Овде се процедура завршава с обзиром на то да смо стигли до последњег елемента у Фенвиковом стаблу.

```   
                    +4
                    |
                    V                
н бин  ф    од до 12345678 3 4 1 2 6 5 1 4  fen
1 0001 0000 1  1  X------- 3                 3
2 0010 0000 1  2  XX------ 3+4               7
3 0011 0010 3  3  --X-----     1             1+4
4 0100 0000 1  4  XXXX---- 3+4+1+2          10+4 
5 0101 0100 5  5  ----X---         6         6
6 0110 0100 5  6  ----XX--         6+5      11
7 0111 0110 7  7  ------X-             1     1
8 1000 0000 1  8  XXXXXXXX 3+4+1+2+6+5+1+4  26+4
```

Објаснимо и докажимо коректност претходне имплементације. Потребно је ажурирати све оне позиције m чији придружени сегмент садржи вредност $k$, тј. све оне позиције $m$ такве да је $k∈(f(m),m]$, тј. $f(m)<k≤m$. Ово никако не може да важи за бројеве $m<k$, а сигурно важи за број $m=k$, јер је $f(k)<k$, када је $k>0$ (а ми претпостављамо да је $1≤k≤n$). За бројеве $m>k$, сигурно важи десна неједнакост и потребно је утврдити да важи лева. Нека је $g(k)$ број који се добија од $k$ тако што се $k$ сабере са бројем који има само једну јединицу у свом бинарном запису и то на позицји на којој се налази последња јединица у бинарном запису броја $k$. На пример, за број $k=101100$, број $g(k)=101100+100=110000$. У имплементацији се број $g(k)$ лако може израчунати као $k + (k \& -k)$. Тврдимо да је најмањи број $m$ који задовољава услов $f(m)<k<m$ управо $g(k)$. Заиста, очигледно важи $k<g(k)$ и $g(k)$  има све нуле од позиције последње јединице у бинарном запису броја $k$ (укључујући и њу), па до краја, па се брисањем његове последње јединице, тј. израчунавањем $f(g(k))$ сигурно добија број који је строго мањи од $k$. Ниједан број $m$ између $k$ и $g(k)$ не може да задовољи услов да је $f(m)<k$. Наиме, сви ти бројеви се поклапају са бројем $k$ на свим позицијама пре крајњих нула, а на позицијама крајњих нула броја $k$ имају бар неку јединицу, чијим се брисањем добија број који је већи или једнак $k$. По истом принципу закључујемо да наредни тражени број мора бити $g(g(k))$, затим $g(g(g(k)))$ итд. све док се не добије неки број који превазилази $n$. Заиста, важи да је $k<g(k)<g(g(k))$. Важи да је $f(g(g(k)))<f(g(k))<k$, па $g(g(k))$ задовољава услов. Ниједан број између $g(k)$ и $g(g(k))$ не може да задовољи услов, јер се сви они поклапају са $g(k)$ у свим бинарним цифрама, осим на његовим крајњим нулама где имају неке јединице. Брисањем последње јединице се добија број који је већи или једнак $g(k)$, па добијени број не може бити мањи од $k$. Отуда следи да су једине позиције које треба ажурирати управо позиције из серије $k$, $g(k)$, $g(g(k))$ итд., све док су оне мање или једнаке $n$, па је наша имплементација коректна.

Остаје још питање како у старту формирати Фенвиково стабло, међутим, формирање се може свести на то да се креира стабло попуњено само нулама, а да се затим увећава вредност једног по једног елемента низа претходном функцијом.

```cpp
// Na osnovu niza a u kom su elementi smešteni
// na pozicijama iz segmenta [1, n] formira Fenvikovo drvo
// i smešta ga u niz drvo (na pozicije iz segmenta [1, n])
void formirajDrvo(int stablo[], int n, int a[]) {
    fill_n(a+1, n, 0);
    for (int k = 1; k <= n; k++)
        dodaj(stablo, n, k, a[k]);
}
```
